/*
 * 
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml;
using CaseExtensions;
using CommandLine;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GenerateTypescriptDTOs
{
    internal static class Program
    {
        private const string AutogenFileDisclaimer = @"/* tslint:disable */

/*
 * Do not edit this file directly!
 * This set of interfaces and enums is autogenerated by `GenerateTypescriptDTOs` 
 * in the project https://github.com/Scripta-Qumranica-Electronica/SQE_API.
 * Changes made there are used to automatically create this file at {ROOT}/ts-dtos
 * whenever the GenerateTypescriptDTOs program is run.
 */

";

        private const string Interface = @"
export interface $Class {
    $Fields
}
";

        private const string _enum = @"
export enum $Enum {
    $Vals
}
";

        private static void Main(string[] args)
        {
            // Parse any command line arguments and pass them on to the ParseSqeSignalrHub method
            Parser.Default.ParseArguments<Options>(args)
                .WithParsed(o => { ParseSqeDtoProject(o.ProjectRoot, o.DtoFolder, o.TsFolder); });
        }

        private static void ParseSqeDtoProject(string projectRoot, string dtoFolder, string tsFolder)
        {
            Console.WriteLine("Parsing the SQE DTOs and creating corresponding typescript interfaces.");

            projectRoot ??= Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "../", "../", "../"));
            dtoFolder ??= Path.GetFullPath(Path.Combine(projectRoot, "../", "../", "sqe-dto"));
            tsFolder ??= Path.GetFullPath(Path.Combine(dtoFolder, "../", "ts-dtos"));

            var dir = new DirectoryInfo(dtoFolder);
            var files = dir.GetFiles("*.cs");
            var classes = new List<ClassDescription>();
            var enums = new List<EnumDescription>();

            // Process the Realtime Hub methods
            Console.WriteLine($"Processing DTO classes from {dtoFolder}.");
            foreach (var file in files)
            {
                Console.WriteLine($"Processing {file.Name}");
                var tmpClasses = ParseSqeDtoClasses(file);
                classes = classes.Union(tmpClasses).ToList();
                var tmpEnums = ParseSqeDtoEnums(file);
                enums = enums.Union(tmpEnums).ToList();
            }

            // Write the classes and enums to TypeScript
            using (var outputFile = new StreamWriter(Path.Combine(tsFolder, "sqe-dtos.ts")))
            {
                outputFile.Write(AutogenFileDisclaimer);

                // Iterate over the classes and parse them into interfaces
                foreach (var classDescription in classes)
                {
                    var intf = Interface.Replace("$Class", classDescription.typescriptType)
                        .Replace("$Fields",
                            string.Join("\n    ", classDescription.fields.Select(x => $"{x.name}: {x.typescriptType}{(x.nullable ? " | null" : "")};")));
                    if (!string.IsNullOrEmpty(classDescription.comments))
                        outputFile.Write(classDescription.comments);
                    outputFile.Write(intf);
                }

                // Iterate over the enums and parse them to Typescript enums
                foreach (var enumDescription in enums)
                {
                    var enumTs = _enum.Replace("$Enum", enumDescription.name)
                        .Replace("$Vals", string.Join("\n    ", enumDescription.vals.Select((x, idx) => $"{x} = {idx},")));
                    outputFile.Write(enumTs);
                }
            }

            Console.WriteLine("Finished creating the SQE signalr typescript interface.");
        }

        /// <summary>
        /// Read a file and parse all the enums found in it
        /// </summary>
        /// <param name="file">The cs file to read</param>
        /// <returns>A list containing descriptions for all the enums</returns>
        private static IEnumerable<EnumDescription> ParseSqeDtoEnums(FileSystemInfo file)
        {
            // Parse the code to the relevant members
            var code = new StreamReader(file.FullName).ReadToEnd();
            var tree = CSharpSyntaxTree.ParseText(code);
            var root = tree.GetCompilationUnitRoot();

            // Grab all enums
            var declaredEnums = root.DescendantNodes().OfType<EnumDeclarationSyntax>().ToList();
            var enums = new List<EnumDescription>();

            // Get the name and values for each enum
            foreach (var enumDeclaration in declaredEnums)
            {
                enums.Add(new EnumDescription(enumDeclaration.Identifier.ToString().ToPascalCase(),
                    enumDeclaration.Members.Select(x => x.Identifier.ToString().ToCamelCase()).ToList()));
            }

            return enums;
        }

        /// <summary>
        /// Read a file and parse all the classes in it
        /// </summary>
        /// <param name="file">The cs file to read</param>
        /// <returns>A list containing descriptions for all the classes</returns>
        private static IEnumerable<ClassDescription> ParseSqeDtoClasses(FileSystemInfo file)
        {
            // Parse the code to the relevant members
            var code = new StreamReader(file.FullName).ReadToEnd();
            var tree = CSharpSyntaxTree.ParseText(code);
            var root = tree.GetCompilationUnitRoot();

            // Get all the classes in the file
            var members = root.DescendantNodes().OfType<ClassDeclarationSyntax>().ToList();
            var classes = new List<ClassDescription>();

            // Parse individual classes
            foreach (var dtoClass in members)
            {
                var classDetails = new ClassDescription(dtoClass.Identifier.ToString().ToPascalCase());
                foreach (var field in dtoClass.DescendantNodes().OfType<PropertyDeclarationSyntax>())
                {
                    var (type, nullable) = ConvertToTypescriptType(field.Type, field.AttributeLists);
                    var fieldDescription = new FieldDescription(field.Identifier.ToString().ToCamelCase(), type, nullable);
                    classDetails.fields.Add(fieldDescription);
                }

                // // Collect the comments to the class
                // if (dtoClass.HasLeadingTrivia && !string.IsNullOrEmpty(dtoClass.GetLeadingTrivia().ToString().Trim()))
                // {
                //     classDetails.comments = ParseComments(dtoClass.GetLeadingTrivia().ToString().Trim());
                // }
                classes.Add(classDetails);
            }

            return classes;
        }

        /// <summary>
        /// Parse the comments into JsDOC
        /// TODO: we have no comments to test with yet
        /// </summary>
        /// <param name="comment"></param>
        /// <returns></returns>
        private static string ParseComments(string comment)
        {
            var xDoc = new XmlDocument();
            xDoc.LoadXml($"<root>{comment.Replace("///", "")}</root>");

            // Get the summary text for the method
            var summary = xDoc.GetElementsByTagName("summary");
            var summaryText = "";
            if (summary.Count == 1)
                summaryText = "\n " + Regex.Replace(summary[0].InnerText, @" +", " ").Trim() + "\n";

            // Get the comments for the parameters
            var parameters = xDoc.GetElementsByTagName("param");
            var parameterText = string.Join(
                "\n",
                parameters.Cast<XmlNode>().Select(x => $" @param {x.Attributes["name"].Value} - {x.InnerText}")
            );

            // Get the comments for the returns
            var returns = xDoc.GetElementsByTagName("returns");
            var returnText = "";
            if (returns.Count == 1)
                returnText = returns[0].InnerText;

            return
                $"\n/**{summaryText}\n{parameterText}\n{(!string.IsNullOrEmpty(returnText) ? " @returns - " + returnText : "")}\n/"
                    .Replace("\n", "\n *");
        }

        /// <summary>
        /// Get a Typescript type and determine the nullability from a submitted c# type
        /// </summary>
        /// <param name="type">The c# type of a property</param>
        /// <param name="attrs">The attributes of the property</param>
        /// <returns>A string representation of the Typescript type and a bool for the property's nullability</returns>
        /// <exception cref="Exception"></exception>
        private static (string, bool) ConvertToTypescriptType(TypeSyntax type, SyntaxList<AttributeListSyntax> attrs)
        {
            // Check the attributes for "required" properties
            var required = attrs.Any(x => x.ToString().Contains("Required"));

            // Check for a generic type
            if (type is GenericNameSyntax genType)
            {
                switch (genType.Identifier.ToString())
                {
                    // Treat the List and IEnumerable like a Typescript array
                    case "List":
                    case "IEnumerable":
                        {
                            var args = genType.TypeArgumentList.Arguments;
                            if (args.Count != 1)
                                throw new Exception($"Array type has {args.Count} arguments");
                            return ($"{SimpleTypeToTypescript(args.FirstOrDefault().ToString()).typeName}[]", !required);
                        }
                    // Parse a Dictionary for Typescript
                    case "Dictionary":
                        {
                            var args = genType.TypeArgumentList.Arguments;
                            if (args.Count != 2)
                                throw new Exception($"Dictionary type has {args.Count} arguments");
                            return ($"{{ [key: {SimpleTypeToTypescript(args[0].ToString()).typeName}] : {SimpleTypeToTypescript(args[1].ToString()).typeName} }}", !required);
                        }
                }
            }

            // We are dealing with a non-generic type, parse it
            var (simpleType, nullable) = SimpleTypeToTypescript(type.ToString());

            return (simpleType, nullable && !required);
        }

        /// <summary>
        /// Get the corresponding Typescript type for a non-generic c# type
        /// </summary>
        /// <param name="type">A string representation of the c# type</param>
        /// <returns>A Typescript string representation and a bool describing the nullability</returns>
        private static (string typeName, bool nullable) SimpleTypeToTypescript(string type)
        {
            var nullableSimple = type.Contains("?");
            switch (type.Replace("?", ""))
            {
                case "byte":
                case "sbyte":
                case "uint16":
                case "uint32":
                case "uint64":
                case "int16":
                case "int32":
                case "int64":
                case "decimal":
                case "double":
                case "single":
                case "uint":
                case "int":
                    return ("number", nullableSimple);
                case "string":
                    return ("string", true);
                case "bool":
                    return ("boolean", nullableSimple);
                case "DateTime":
                    return ("Date", true);
                default:
                    return (type, true);
            }
        }

        /// <summary>
        ///     Optional command line arguments (see https://github.com/commandlineparser/commandline)
        /// </summary>
        private class Options
        {
            [Option('p', "project-folder", Required = false, HelpText = "Specify project folder path.")]
            public string ProjectRoot { get; set; }

            [Option('d', "dto-folder", Required = false, HelpText = "Specify dto folder path.")]
            public string DtoFolder { get; set; }

            [Option('t', "ts-folder", Required = false, HelpText = "Specify typescript definitions folder path.")]
            public string TsFolder { get; set; }
        }
    }

    public class ClassDescription
    {
        public ClassDescription(string typescriptType)
        {
            this.fields = new List<FieldDescription>();
            this.typescriptType = typescriptType;
            this.comments = null;
        }

        public List<FieldDescription> fields { get; set; }
        public string typescriptType { get; set; }
        public string comments { get; set; }
    }

    public class FieldDescription
    {
        public FieldDescription(string name, string typescriptType, bool nullable)
        {
            this.name = name;
            this.typescriptType = typescriptType;
            this.nullable = nullable;
        }

        public string name { get; set; }
        public string typescriptType { get; set; }
        public bool nullable { get; set; }
    }

    public class EnumDescription
    {
        public EnumDescription(string name, List<string> vals)
        {
            this.name = name;
            this.vals = vals;
        }

        public string name { get; set; }
        public List<string> vals { get; set; }
    }
}