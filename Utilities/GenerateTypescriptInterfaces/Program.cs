/*
 * 
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using CaseExtensions;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GenerateTypescriptInterfaces
{
    internal static class Program
    {
        private const string _hubClassTemplate = @"namespace SQE.API.Server.RealtimeHubs
{
    public partial class MainHub
    {";

        private const string _autogenFileDisclaimer = @"/*
 * Do not edit this file directly!
 * This hub class is autogenerated by the `sqe-realtime-hub-builder` project
 * based on the controllers in the `sqe-api-server` project. Changes made
 * there will automatically be incorporated here the next time the 
 * `sqe-realtime-hub-builder` is run.
 */

";

        private const string _subscriptionHubDisclaimer = @"/*
 * This file is autogenerated from (solution root)/sqe-realtime-hub-builder/SubscriptionHub.cs.txt
 * Please edit that file if any changes need to be made.
 */

";

        private static readonly Regex _rx = new Regex(
            @"Task?<(?<return>.*)?>",
            RegexOptions.Compiled | RegexOptions.IgnoreCase
        );

        private static readonly Regex _rxl = new Regex(
            @"List?<(?<return>.*)?>",
            RegexOptions.Compiled | RegexOptions.IgnoreCase
        );

        private static readonly Regex _rxi = new Regex(
            @"interface (?<type>.*?) ",
            RegexOptions.Compiled | RegexOptions.IgnoreCase
        );

        private static void Main(string[] args)
        {
            ParseSqeSignalrHub();
        }

        private static void ParseSqeSignalrHub()
        {
            Console.WriteLine("Parsing the SignalR hub and creating corresponding typescript interfaces.");

            // TODO: Can we find a better way to resolve these paths instead of all the backtracking?
            var projectRoot =
                Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "../", "../", "../"));
            var apiServerRoot = Path.GetFullPath(Path.Combine(projectRoot, "../", "../", "sqe-api-server"));
            var tsFolder = Path.GetFullPath(Path.Combine(apiServerRoot, "../", "ts-dtos"));
            var hubFolder = Path.GetFullPath(Path.Combine(apiServerRoot, "RealtimeHubs"));

            var dir = new DirectoryInfo(hubFolder);
            var files = dir.GetFiles("*.cs");
            var hubMethods = new List<string>();
            var hubInterfaceMethods = new List<string>();

            // Process the Realtime Hub methods
            Console.WriteLine($"Processing realtime hub methods from {hubFolder}.");
            foreach (var file in files)
            {
                if (file.Name != "HubInterface.cs")
                {
                    Console.WriteLine(file.Name);
                    var tmpHubMethods = ParseSqeHttpControllers(file);
                    hubMethods = hubMethods.Union(tmpHubMethods).ToList();
                }
                else
                    hubInterfaceMethods = ParseSqeHttpControllers(file);
            }

            foreach (var hubMethod in hubMethods)
                Console.WriteLine(hubMethod);

            Console.WriteLine("Interface");
            foreach (var hubMethod in hubInterfaceMethods)
                Console.WriteLine(hubMethod);

            WriteTsHub(hubMethods, hubInterfaceMethods, tsFolder, projectRoot);

        }

        private static List<string> ParseSqeHttpControllers(FileInfo file)
        {
            Console.WriteLine($"Parsing {file.FullName}");

            // Parse the code to the relevant members
            var code = new StreamReader(file.FullName).ReadToEnd();
            var tree = CSharpSyntaxTree.ParseText(code);
            var root = tree.GetCompilationUnitRoot();
            var members = root.DescendantNodes().OfType<MemberDeclarationSyntax>().ToList();
            var hubMethods = new List<string>();

            // Parse individual methods
            foreach (var method in members.OfType<MethodDeclarationSyntax>().ToList())
            {
                // Copy the comments
                //WriteMethodCommentsToFile(method, outputFile);
                var methodName = method.Identifier.Text;
                //Console.WriteLine(methodName);

                // Format the method modifiers
                var methodModifiers = string.Join(" ", method.Modifiers.Select(x => x.Text));
                //Console.WriteLine(methodModifiers);

                // Format the return type
                var returnType = ConvertToTypescriptType(ProcessReturnType(method));

                //Console.WriteLine(returnType);

                // Format the method parameters
                var methodParams = string.Join(
                    ", ",
                    method.ParameterList.Parameters.Select(
                        x => $"{x.Identifier}: {ConvertToTypescriptType(x.Type.ToString())}"
                    )
                );
                //Console.WriteLine(methodParams);
                var typescriptSig = $"\t\t{methodName}({methodParams}): {returnType}";
                hubMethods.Add(typescriptSig);
            }
            return hubMethods;
        }

        private static string ConvertToTypescriptType(string type)
        {
            switch (type)
            {
                case "byte":
                case "sbyte":
                case "uint16":
                case "uint32":
                case "uint64":
                case "int16":
                case "int32":
                case "int64":
                case "decimal":
                case "double":
                case "single":
                case "uint":
                case "int":
                    return "number";
                case "string":
                    return "string";
                case "bool":
                    return "boolean";
            }
            if (type != null && type.Contains("Task"))
            {
                var matches = _rx.Matches(type);
                type = matches.Count >= 1 ? ConvertToTypescriptType(matches[0].Groups["return"].Value) : "void";
            }
            if (type != null && type.Contains("List<"))
            {
                var matches = _rxl.Matches(type);
                type = matches.Count >= 1 ? ConvertToTypescriptType(matches[0].Groups["return"].Value) + "[]" : "[]";
            }

            return type;
        }

        private static string ProcessReturnType(MethodDeclarationSyntax method)
        {
            const string actionResultString = "<ActionResult";
            return method.ReturnType.ToString().Contains(actionResultString)
                ? Regex.Replace(
                    method.ReturnType.ToString().Replace(actionResultString, ""),
                    ">$",
                    ""
                )
                : method.ReturnType.ToString();
        }

        private static void WriteTsHub(List<string> hubMethods, List<string> hubInterfaceMethods, string tsFolder, string baseFolder)
        {
            var types = new StreamReader($"{tsFolder}/sqe-dtos.ts").ReadToEnd();
            var matches = _rxi.Matches(types);
            //type = matches.Count >= 1 ? ConvertToTypescriptType(matches[0].Groups["return"].Value) : "void";
            foreach (var match in matches.ToList())
                Console.WriteLine(match.Groups["type"].Value);
            var template = new StreamReader($"{baseFolder}/SqeHubInterfaceTemplate.txt").ReadToEnd();
            using (var outputFile = new StreamWriter(Path.Combine(tsFolder, "sqe-hub-types.ts")))
            {
                outputFile.Write(template
                    .Replace("$IMPORTS", string.Join("\n", matches.ToList().Select(x => $"\t{x.Groups["type"].Value},")))
                    .Replace("$CLIENTMETHODS", string.Join(";\n", hubInterfaceMethods))
                    .Replace("$SERVERMETHODS", string.Join(";\n", hubMethods))
                );
            }
        }
    }
}